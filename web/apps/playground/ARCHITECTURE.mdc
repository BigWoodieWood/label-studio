---
description:
globs:
alwaysApply: false
---
# Playground Architecture

## Overview
The LabelStudio Playground is a standalone, embeddable React application for editing and previewing LabelStudio XML labeling configurations. It is designed to be embedded via iframe in documentation or external web applications, providing a focused environment for working with XML-based labeling configs and live previewing the LabelStudio interface.

## Main Components

### 1. `PlaygroundApp`
- **Location:** `src/components/PlaygroundApp.tsx`
- **Role:** The main application component. Handles:
  - State for the XML config, loading, error, and LabelStudio interfaces.
  - Parsing URL parameters for config and interface options.
  - Fetching and decoding configs from base64 or external URLs.
  - Rendering the code editor and preview panels side by side using Tailwind CSS for layout.

### 2. `PlaygroundPreview`
- **Location:** `src/components/PlaygroundPreview.tsx`
- **Role:** Renders the live LabelStudio preview panel.
  - Dynamically loads the `@humansignal/editor` package and instantiates a LabelStudio instance with the current config and interface options.
  - Handles cleanup of the LabelStudio instance on config/interface changes or unmount.
  - Displays loading and error states using Tailwind classes.

### 3. `main.tsx`
- **Role:** Entry point. Mounts the `PlaygroundApp` to the DOM.

## Data Flow
- On load, `PlaygroundApp` parses URL parameters:
  - `?config` (base64-encoded XML config)
  - `?configUrl` (URL to fetch XML config)
  - `?interfaces` (comma-separated list of LabelStudio interface options)
- The config is loaded and stored in React state.
- The code editor is a controlled component, updating the config state on change.
- The preview panel receives the current config and interface options as props and re-renders the LabelStudio instance accordingly.

## Underlying Libraries

### React
- The app is built with React (function components, hooks, strict mode).
- State and effects are managed with `useState` and `useEffect`.

### Tailwind CSS
- All layout, spacing, color, and typography is handled with Tailwind utility classes.
- Only semantic and token-based Tailwind classes are used, following project rules.

### @humansignal/ui
- Provides the `CodeEditor` component for XML editing.
- Ensures consistent UI and design token usage across the app.

### @humansignal/editor
- Provides the LabelStudio labeling interface for live preview.
- Dynamically imported in the preview panel for performance and to avoid loading unnecessary code until needed.
- The LabelStudio instance is created with the current config and interface options, and is destroyed/cleaned up on changes.

## URL-based API
- The app can be configured via URL parameters:
  - `?config` (base64-encoded XML config string)
  - `?configUrl` (URL to fetch XML config)
  - `?interfaces` (comma-separated list of LabelStudio interface options)
- This allows external documentation or apps to embed the playground with preloaded configs and custom preview options.

## Embeddability
- The app is fully responsive and designed to be embedded via iframe.
- All UI is self-contained and does not require authentication or external state.

## Extensibility
- Components are split into single-file-per-component for maintainability, and all live under `src/components/`.
- The code editor and preview logic are decoupled, allowing for future enhancements (e.g., validation, additional preview options, custom data, etc).
- The app can be extended to support more URL parameters, additional LabelStudio features, or integration with other HumanSignal libraries.

## Directory Structure

```
web/apps/playground/
  README.mdc
  API.mdc
  ARCHITECTURE.mdc
  EMBED.mdc
  src/
    main.tsx
    index.html
    components/
      PlaygroundApp.tsx
      PlaygroundPreview.tsx
```

## Summary
The Playground app is a modern, modular, and embeddable tool for experimenting with and sharing LabelStudio configs. It leverages the HumanSignal UI and editor libraries, is styled with Tailwind, and is designed for easy integration into documentation and external web applications.
